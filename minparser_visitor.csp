package minparser_visitor
import parsergen

namespace domain_type
    constant none = 1
    constant loop = 2
end

@begin
constant beg_blk_op = {
    1 : "BLCK ENTER",
    2 : "BLCK ENTER"
}.to_hash_map(),
end_blk_op = {
    1 : "BLCK LEAVE",
    2 : "BLCK REPEAT"
}.to_hash_map()
@end

class domain
    var pending_jump = new array
    var decl_map = new hash_map
    var op_start = 0
    var type = 0
end

class main
    var target = system.out
    var indent = -1
    var op_offset = 0
    var op_sequence = new array
    var blk_stack = {new domain}
    var pending_jump = new array
    function insert_op(offset, op)
        op_sequence.push_back(offset : op)
    end
    function gen_op(op)
        op_sequence.push_back(op_offset++ : op)
    end
    function beg_blk(type)
        blk_stack.push_front(new domain)
        blk_stack.front.op_start = op_offset++
        blk_stack.front.type = type
    end
    function decl_var(id)
        gen_op("DECL " + id)
        link map = blk_stack.front.decl_map
        if map.exist(id)
            target.println("Error: variable " + id + "redefined")
        else
            map.insert(id, op_offset)
        end
    end
    function jump_begin(op, type)
        foreach d in blk_stack
            if d.type == type
                gen_op(op + " " + d.op_start)
                break
            end
        end
    end
    function jump_end(op, type)
        foreach d in blk_stack
            if d.type == type
                d.pending_jump.push_back(op_offset++ : op)
                break
            end
        end
    end
    function end_blk()
        var d = blk_stack.pop_front()
        if d.decl_map.empty()
            insert_op(d.op_start, "SKIP")
        else
            insert_op(d.op_start, beg_blk_op[d.type])
            gen_op(end_blk_op[d.type])
        end
        var ops = d.pending_jump
        foreach op in ops
            insert_op(op.key, op.value + " " + op_offset)
        end
    end
    function get_op_sequence()
        var seq = op_sequence
        seq.push_back(seq.size : "HALT")
        seq.sort([](lhs, rhs)->lhs.key < rhs.key)
        var ops = new array
        var tag_map = new array
        foreach it in seq
            if it.value != "SKIP"
                tag_map[it.key] = ops.size
                ops.push_back(it.value)
            end
        end
        foreach it in ops
            var op_code = it.split({' '})
            switch op_code[0]
                case "JUMP"
                    it = op_code[0] + " " + tag_map[to_integer(op_code[1])]
                end
                case "JMPT"
                    it = op_code[0] + " " + tag_map[to_integer(op_code[1])]
                end
                case "JMPF"
                    it = op_code[0] + " " + tag_map[to_integer(op_code[1])]
                end
            end
        end
        return ops
    end
    function print_indent()
        foreach i in range(indent) do target.print('\t')
    end
    function visit_declaration(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_expr(nodes)
        var idx = 0
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(",")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_cond_postfix(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "?")
                matched = true
                # Visit term "?"
                ++idx; target.print("?")
                # Recursive Visit value-expr
                this.visit_value_expr(nodes[idx++].nodes)
                # Visit term ":"
                ++idx; target.print(":")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                matched = true
                # Visit term ":"
                ++idx; target.print(":")
                # Recursive Visit value-expr
                this.visit_value_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_value_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "logic-or-expr")
                matched = true
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_conv_expr(nodes)
        var idx = 0
        # Recursive Visit unary-expr
        this.visit_unary_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=>" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=>")
                    matched = true
                    # Visit term "=>"
                    ++idx; target.print("=>")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
                    matched = true
                    # Visit term "as"
                    ++idx; target.print("as")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_capture_list(nodes)
        var idx = 0
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
            # Visit term "="
            ++idx; target.print("=")
        end
        # Visit id token
        target.print(nodes[idx++].data)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(",")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
    end
    function visit_block_stmt(nodes)
        var idx = 0
        # Visit term "block"
        ++idx; target.print("block")
        # Visit endl token
        target.print(nodes[idx++].data)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        ++idx; target.print("end")
        # Visit endl token
        target.print(nodes[idx++].data)
    end
    function visit_endblock(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "end-stmt")
                matched = true
                # Recursive Visit end-stmt
                this.visit_end_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
                matched = true
                # Recursive Visit else-stmt
                this.visit_else_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_stmts(nodes)
        var idx = 0
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                target.print(nodes[idx++].data)
            end
        end
    end
    function visit_begin(nodes)
        var idx = 0
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
    end
    function visit_statement(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "block-stmt")
                matched = true
                # Recursive Visit block-stmt
                this.visit_block_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "if-stmt")
                matched = true
                # Recursive Visit if-stmt
                this.visit_if_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "loop-stmt")
                matched = true
                # Recursive Visit loop-stmt
                this.visit_loop_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "control-stmt")
                matched = true
                # Recursive Visit control-stmt
                this.visit_control_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr-stmt")
                matched = true
                # Recursive Visit expr-stmt
                this.visit_expr_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "var")
                matched = true
                # Visit term "var"
                ++idx; # target.print("var")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "link")
                matched = true
                # Visit term "link"
                ++idx; target.print("link")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "constant")
                matched = true
                # Visit term "constant"
                ++idx; target.print("constant")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit var-def
        this.visit_var_def(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_add_expr(nodes)
        var idx = 0
        # Recursive Visit mul-expr
        var lhs = nodes[idx++].nodes
        var op = null
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+")
                    matched = true
                    # Visit term "+"
                    ++idx; op = "OPER ADD"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                    matched = true
                    # Visit term "-"
                    ++idx; op = "OPER SUB"
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit add-expr
            this.visit_add_expr(nodes[idx++].nodes)
            this.visit_mul_expr(lhs)
            gen_op(op)
        else
            this.visit_mul_expr(lhs)
        end
    end
    function visit_unary_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "unary-op")
                matched = true
                # Recursive Visit unary-op
                this.visit_unary_op(nodes[idx++].nodes)
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                matched = true
                # Condition
                block
                    var matched = false
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                        matched = true
                        # Visit term "new"
                        ++idx; target.print("new")
                    end
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                        matched = true
                        # Visit term "gcnew"
                        ++idx; target.print("gcnew")
                    end
                    if !matched
                    	# Error
                    	return
                    end
                end
                # Recursive Visit visit-expr
                this.visit_visit_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                    # Recursive Visit array
                    this.visit_array(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prim-expr")
                matched = true
                # Recursive Visit prim-expr
                this.visit_prim_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
                    # Recursive Visit postfix-expr
                    this.visit_postfix_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_prim_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "visit-expr")
                matched = true
                # Recursive Visit visit-expr
                this.visit_visit_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "constant")
                matched = true
                # Recursive Visit constant
                this.visit_constant(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_object(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                matched = true
                # Recursive Visit array
                this.visit_array(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "str")
                matched = true
                # Visit str token
                gen_op("PUSH " + nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "local")
                matched = true
                # Visit term "local"
                ++idx; target.print("local")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "global")
                matched = true
                # Visit term "global"
                ++idx; target.print("global")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "ecsx-extend")
                matched = true
                # Recursive Visit ecsx-extend
                this.visit_ecsx_extend(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "element")
                matched = true
                # Recursive Visit element
                this.visit_element(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "char")
                matched = true
                # Visit char token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_else_stmt(nodes)
        var idx = 0
        # Visit term "else"
        ++idx; target.print("else")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "if")
            # Visit term "if"
            ++idx; target.print("if")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        target.print(nodes[idx++].data)
    end
    function visit_ecsx_extend(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "::"
        ++idx; target.print("::")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_namespace_stmt(nodes)
        var idx = 0
        # Visit term "namespace"
        ++idx; target.print("namespace")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit endl token
        target.print(nodes[idx++].data)
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        ++idx; target.print("end")
        # Visit endl token
        target.print(nodes[idx++].data)
    end
    function visit_ignore(nodes)
        var idx = 0
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
            # Visit endl token
            target.print(nodes[idx++].data)
        end
    end
    function visit_element(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                gen_op("LOAD " + nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall")
                    matched = true
                    # Recursive Visit fcall
                    this.visit_fcall(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    matched = true
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_constant(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "num")
                matched = true
                # Visit num token
                gen_op("PUSH " + nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "null")
                matched = true
                # Visit term "null"
                ++idx; gen_op("PUSH null")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "true")
                matched = true
                # Visit term "true"
                ++idx; gen_op("PUSH true")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "false")
                matched = true
                # Visit term "false"
                ++idx; gen_op("PUSH false")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit var-bind-list
        this.visit_var_bind_list(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(",")
            # Recursive Visit var-bind-list
            this.visit_var_bind_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_array(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term "}"
        ++idx; target.print("}")
    end
    function visit_fcall(nodes)
        var idx = 0
        # Visit term "("
        ++idx; #target.print("(")
        # Optional
        var op_args = op_offset
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; gen_op("CALL " + (op_offset - op_args))
    end
    function visit_bind_expr(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit bind-list
        this.visit_bind_list(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(",")
            # Recursive Visit bind-list
            this.visit_bind_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_lambda_expr(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "capture-list")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
        # Visit term "]"
        ++idx; target.print("]")
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
        # Recursive Visit lambda-body
        this.visit_lambda_body(nodes[idx++].nodes)
    end
    function visit_decl_stmts(nodes)
        var idx = 0
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration")
            # Recursive Visit declaration
            this.visit_declaration(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                target.print(nodes[idx++].data)
            end
        end
    end
    function visit_lambda_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx; target.print("{")
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
                    # Recursive Visit statement
                    this.visit_statement(nodes[idx++].nodes)
                    # Repeat
                    while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                        # Visit endl token
                        target.print(nodes[idx++].data)
                    end
                end
                # Visit term "}"
                ++idx; target.print("}")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                matched = true
                # Visit term "->"
                ++idx; target.print("->")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_asi_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; gen_op("OPER ASI") # target.print("=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":=")
                matched = true
                # Visit term ":="
                ++idx; gen_op("OPER LINKASI") #target.print(":=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+=")
                matched = true
                # Visit term "+="
                ++idx; gen_op("OPER ADDASI") #target.print("+=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-=")
                matched = true
                # Visit term "-="
                ++idx; gen_op("OPER SUBASI") #target.print("-=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*=")
                matched = true
                # Visit term "*="
                ++idx; gen_op("OPER MULASI") #target.print("*=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/=")
                matched = true
                # Visit term "/="
                ++idx; gen_op("OPER DIVASI") #target.print("/=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%=")
                matched = true
                # Visit term "%="
                ++idx; gen_op("OPER MODASI") #target.print("%=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^=")
                matched = true
                # Visit term "^="
                ++idx; gen_op("OPER POWASI") #target.print("^=")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_cond_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "logic-or-expr")
                matched = true
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-postfix")
                    # Recursive Visit cond-postfix
                    this.visit_cond_postfix(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_relat_expr(nodes)
        var idx = 0
        # Recursive Visit add-expr
        # this.visit_add_expr(nodes[idx++].nodes)
        var lhs = nodes[idx++].nodes
        var op = null
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">")
                    matched = true
                    # Visit term ">"
                    ++idx; op = "oper abocmp"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<")
                    matched = true
                    # Visit term "<"
                    ++idx; op = "oper undcmp"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=")
                    matched = true
                    # Visit term ">="
                    ++idx; op = "oper aepcmp"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
                    matched = true
                    # Visit term "<="
                    ++idx; op = "oper ueqcmp"
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit relat-expr
            this.visit_relat_expr(nodes[idx++].nodes)
            this.visit_add_expr(lhs)
            gen_op(op.toupper())
        else
            this.visit_add_expr(lhs)
        end
    end
    function visit_postfix_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
            # Recursive Visit postfix-expr
            this.visit_postfix_expr(nodes[idx++].nodes)
        end
    end
    function visit_argument_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                    # Visit term "="
                    ++idx; target.print("=")
                end
                # Visit id token
                target.print(nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                    # Visit term ":"
                    ++idx; target.print(":")
                    # Recursive Visit visit-expr
                    this.visit_visit_expr(nodes[idx++].nodes)
                end
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                    # Visit term ","
                    ++idx; target.print(",")
                    # Recursive Visit argument-list
                    this.visit_argument_list(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_visit_expr(nodes)
        var idx = 0
        # Recursive Visit object
        this.visit_object(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                    matched = true
                    # Visit term "->"
                    ++idx; target.print("->")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                    matched = true
                    # Visit term "."
                    ++idx; target.print(".")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_endline(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                idx++ # target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(";")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_basic_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "bind-expr")
                matched = true
                # Recursive Visit bind-expr
                this.visit_bind_expr(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print("=")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-expr")
                matched = true
                # Recursive Visit cond-expr
                var lhs = nodes[idx++].nodes
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "asi-op")
                    # Recursive Visit asi-op
                    var op = nodes[idx++].nodes
                    # Recursive Visit basic-expr
                    this.visit_basic_expr(nodes[idx++].nodes)
                    this.visit_cond_expr(lhs)
                    this.visit_asi_op(op)
                else
                    this.visit_cond_expr(lhs)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_control_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "break")
                matched = true
                # Visit term "break"
                ++idx; jump_end("JUMP", domain_type.loop) #target.print("break")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "continue")
                matched = true
                # Visit term "continue"
                ++idx; jump_begin("JUMP", domain_type.loop) #target.print("continue")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_loop_stmt(nodes)
        var idx = 0
        # Visit term "loop"
        ++idx; # target.print("loop")
        beg_blk(domain_type.loop)
        # Visit endl token
        idx++ # target.print(nodes[idx++].data)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        ++idx; # target.print("end")
        # Visit endl token
        # target.print(nodes[idx++].data)
        end_blk()
    end
    function visit_bind_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "bind-expr")
                matched = true
                # Recursive Visit bind-expr
                this.visit_bind_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_logic_or_expr(nodes)
        var idx = 0
        # Recursive Visit logic-and-expr
        this.visit_logic_and_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||")
                    matched = true
                    # Visit term "||"
                    ++idx; target.print("||")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
                    matched = true
                    # Visit term "or"
                    ++idx; target.print("or")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-or-expr
            this.visit_logic_or_expr(nodes[idx++].nodes)
        end
    end
    function visit_equal_expr(nodes)
        var idx = 0
        # Recursive Visit relat-expr
        var lhs = nodes[idx++].nodes
        var op = null
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "is" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "not")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==")
                    matched = true
                    # Visit term "=="
                    ++idx; op = "OPER EQU" # target.print("==")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
                    matched = true
                    # Visit term "!="
                    ++idx; op = "OPER NEQ" # target.print("!=")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "is")
                    matched = true
                    # Visit term "is"
                    ++idx; op = "OPER ISA" # target.print("is")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "not")
                    matched = true
                    # Visit term "not"
                    ++idx; op = "OPER NOT" # target.print("not")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit equal-expr
            this.visit_equal_expr(nodes[idx++].nodes)
            this.visit_relat_expr(lhs)
            gen_op(op)
        else
            this.visit_relat_expr(lhs)
        end
    end
    function visit_mul_expr(nodes)
        var idx = 0
        # Recursive Visit conv-expr
        var lhs = nodes[idx++].nodes
        var op = null
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    ++idx; op = "OPER MUL"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/")
                    matched = true
                    # Visit term "/"
                    ++idx; op = "OPER DIV"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%")
                    matched = true
                    # Visit term "%"
                    ++idx; op = "OPER MOD"
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
                    matched = true
                    # Visit term "^"
                    ++idx; op = "OPER POW"
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit mul-expr
            this.visit_mul_expr(nodes[idx++].nodes)
            this.visit_conv_expr(lhs)
            gen_op(op)
        else
            this.visit_conv_expr(lhs)
        end
    end
    function visit_unary_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "typeid")
                matched = true
                # Visit term "typeid"
                ++idx; target.print("typeid")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                matched = true
                # Visit term "*"
                ++idx; target.print("*")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&")
                matched = true
                # Visit term "&"
                ++idx; target.print("&")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!")
                matched = true
                # Visit term "!"
                ++idx; target.print("!")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "not")
                matched = true
                # Visit term "not"
                ++idx; target.print("not")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_index(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "[")
                matched = true
                # Visit term "["
                ++idx; target.print("[")
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr")
                    # Recursive Visit add-expr
                    this.visit_add_expr(nodes[idx++].nodes)
                end
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                    # Visit term ":"
                    ++idx; target.print(":")
                    # Optional
                    if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr")
                        # Recursive Visit add-expr
                        this.visit_add_expr(nodes[idx++].nodes)
                    end
                    # Optional
                    if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                        # Visit term ":"
                        ++idx; target.print(":")
                        # Optional
                        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr")
                            # Recursive Visit add-expr
                            this.visit_add_expr(nodes[idx++].nodes)
                        end
                    end
                end
                # Visit term "]"
                ++idx; target.print("]")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "[")
                matched = true
                # Visit term "["
                ++idx; target.print("[")
                # Visit term "::"
                ++idx; target.print("::")
                # Visit term "]"
                ++idx; target.print("]")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_list(nodes)
        var idx = 0
        # Visit id token
        var id_token = nodes[idx++].data
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; # target.print("=")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                decl_var(id_token)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
                matched = true
                # Visit term "as"
                ++idx; target.print("as")
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                    # Recursive Visit array
                    this.visit_array(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(",")
            # Recursive Visit var-list
            this.visit_var_list(nodes[idx++].nodes)
        end
    end
    function visit_var_def(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print("=")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-list")
                matched = true
                # Recursive Visit var-list
                this.visit_var_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_if_stmt(nodes)
        var idx = 0
        # Visit term "if"
        ++idx; # target.print("if")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        idx++ # target.print(nodes[idx++].data)
        # Recursive Visit stmts
        var cur_op = op_offset++
        beg_blk(domain_type.none)
        this.visit_stmts(nodes[idx++].nodes)
        end_blk()
        insert_op(cur_op, "JMPF " + op_offset)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
            # Recursive Visit else-stmt
            idx++ # this.visit_else_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            beg_blk(domain_type.none)
            this.visit_stmts(nodes[idx++].nodes)
            end_blk()
        end
        # Visit term "end"
        ++idx; #target.print("end")
        # Visit endl token
        # target.print(nodes[idx++].data)
    end
    function visit_expr_stmt(nodes)
        var idx = 0
        # Recursive Visit expr
        this.visit_expr(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_end_stmt(nodes)
        var idx = 0
        # Visit term "end"
        ++idx; target.print("end")
        # Visit endl token
        target.print(nodes[idx++].data)
    end
    function visit_logic_and_expr(nodes)
        var idx = 0
        # Recursive Visit equal-expr
        this.visit_equal_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&")
                    matched = true
                    # Visit term "&&"
                    ++idx; target.print("&&")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
                    matched = true
                    # Visit term "and"
                    ++idx; target.print("and")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-and-expr
            this.visit_logic_and_expr(nodes[idx++].nodes)
        end
    end
    function run(os, ast)
        this.target = os
        this.visit_begin(ast.nodes)
    end
end
